<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>microWakeWord Recorder</title>
  <style>
    :root{
      --bg: #070709;
      --panel: rgba(18, 18, 22, 0.78);
      --panel2: rgba(24, 24, 30, 0.86);
      --text: #e9e9ee;
      --muted: #a2a2ad;
      --line: rgba(255,255,255,0.10);
      --orange: #ff8a2a;
      --orange2:#ffb066;
      --ok:#38d39f;
      --warn:#ffb020;
      --err:#ff4a4a;
      --shadow: 0 18px 50px rgba(0,0,0,0.45);
      --radius: 16px;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(900px 500px at 12% 6%, rgba(255, 138, 42, 0.12), transparent 55%),
        radial-gradient(700px 420px at 80% 14%, rgba(255, 176, 102, 0.09), transparent 60%),
        radial-gradient(800px 600px at 50% 100%, rgba(255, 138, 42, 0.06), transparent 55%),
        linear-gradient(180deg, #050506 0%, #09090d 100%);
    }

    .wrap { max-width: 940px; margin: 0 auto; padding: 26px 18px 42px; }

    h2 { margin: 0 0 8px; font-size: 22px; letter-spacing: 0.2px; }
    p { margin: 0 0 14px; color: var(--muted); line-height: 1.45; }

    .topbar {
      display:flex; align-items:center; justify-content:space-between;
      gap: 12px; margin-bottom: 14px;
    }

    .brand { display:flex; align-items:center; gap:10px; }
    .logo {
      width: 38px; height: 38px; border-radius: 12px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,176,102,0.55), rgba(255,138,42,0.25) 45%, rgba(0,0,0,0) 72%),
        linear-gradient(180deg, rgba(255,138,42,0.22), rgba(255,138,42,0.06));
      border: 1px solid rgba(255,138,42,0.30);
      box-shadow: 0 10px 28px rgba(255,138,42,0.08);
    }

    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }

    .card {
      border: 1px solid var(--line);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-radius: var(--radius);
      padding: 16px;
      margin-top: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    .muted { color: var(--muted); }

    input[type="text"], input[type="number"]{
      padding: 11px 12px;
      font-size: 15px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.35);
      color: var(--text);
      outline: none;
    }
    input[type="text"] { width: 420px; max-width: 100%; }
    input[type="number"] { width: 120px; }
    input::placeholder { color: rgba(233,233,238,0.35); }
    select {
      padding: 11px 12px;
      font-size: 15px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.35);
      color: var(--text);
      outline: none;
    }

    button {
      padding: 10px 14px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      transition: transform 0.04s ease, border-color .15s ease, background .15s ease;
    }
    button:hover { border-color: rgba(255,138,42,0.35); background: rgba(255,255,255,0.08); }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: 0.45; cursor: not-allowed; }

    .primary {
      border-color: rgba(255,138,42,0.40);
      background: linear-gradient(180deg, rgba(255,138,42,0.24), rgba(255,138,42,0.12));
    }
    .primary:hover { border-color: rgba(255,138,42,0.65); }

    .pill {
      display:inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--muted);
      font-size: 12px;
    }
    .pill.ok   { color: var(--ok); border-color: rgba(56,211,159,0.25); background: rgba(56,211,159,0.08); }
    .pill.warn { color: var(--warn); border-color: rgba(255,176,32,0.25); background: rgba(255,176,32,0.08); }
    .pill.err  { color: var(--err); border-color: rgba(255,74,74,0.25); background: rgba(255,74,74,0.08); }

    details { margin-top: 10px; }
    summary { cursor: pointer; color: var(--orange2); }
    summary:hover { color: var(--orange); }

    label { display:flex; gap:10px; align-items:center; }
    input[type="range"] { width: 240px; }

    .meter {
      height: 10px;
      background: rgba(255,255,255,0.08);
      border-radius: 999px;
      overflow: hidden;
      width: 280px;
      border: 1px solid rgba(255,255,255,0.10);
    }
    .meter > div {
      height: 10px;
      width: 0%;
      background: linear-gradient(90deg, rgba(255,138,42,0.55), rgba(255,176,102,0.85));
    }

    pre {
      background: rgba(0,0,0,0.55);
      color: #e6e6ea;
      padding: 12px;
      border-radius: 14px;
      overflow: auto;
      max-height: 300px;
      border: 1px solid rgba(255,255,255,0.10);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .big { font-size: 16px; }

    .divider {
      height: 1px;
      width: 100%;
      background: rgba(255,255,255,0.10);
      margin: 12px 0;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h2 id="pageTitle">üéôÔ∏è microWakeWord Personal Recorder</h2>
          <p class="muted" id="pageSubtitle">Enter a wake word, test TTS pronunciation, then record takes. Recording starts when you speak and stops after silence.</p>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="row">
        <input id="phrase" type="text" placeholder='e.g. "tater totterson"' />
        <select id="langSelect" title="Language">
          <option id="langAutoOpt" value="auto">Auto</option>
          <option id="langEnOpt" value="en">English</option>
          <option id="langRuOpt" value="ru">–†—É—Å—Å–∫–∏–π</option>
        </select>
        <button id="startSessionBtn" class="primary">Start session</button>
        <button id="ttsBtn" disabled>üîä Test TTS</button>
        <span id="sessionPill" class="pill">No session</span>
      </div>

      <div class="row" style="margin-top:10px;">
        <label class="muted"><span id="labelSpeakers">Speakers</span>
          <input id="speakersTotal" type="number" min="1" max="10" value="1" />
        </label>
        <label class="muted"><span id="labelTakesPerSpeaker">Takes / speaker</span>
          <input id="takesPerSpeaker" type="number" min="1" max="50" value="10" />
        </label>
        <span id="speakerPill" class="pill">Speaker: -</span>
      </div>

      <details>
        <summary id="advancedSummary">Advanced (if it‚Äôs too sensitive / not sensitive enough)</summary>
        <div style="margin-top:10px;">
          <label>
            <span id="labelStartSensitivity">Start sensitivity</span>
            <input id="startThresh" type="range" min="0.005" max="0.08" step="0.001" value="0.02" />
            <span id="startThreshVal" class="muted"></span>
          </label>
          <label>
            <span id="labelSilenceStop">Silence stop (ms)</span>
            <input id="silenceMs" type="range" min="300" max="2000" step="50" value="900" />
            <span id="silenceMsVal" class="muted"></span>
          </label>
          <label>
            <span id="labelMinTakeLength">Min take length (ms)</span>
            <input id="minTakeMs" type="range" min="300" max="2000" step="50" value="650" />
            <span id="minTakeMsVal" class="muted"></span>
          </label>
        </div>
      </details>
    </div>

    <div class="card">
      <div class="row">
        <button id="beginBtn" disabled class="primary">üé¨ Begin recording</button>
        <button id="resetBtn" disabled>üßπ Reset recordings</button>
        <button id="trainBtn" disabled>üß† Start training</button>
        <span id="status" class="pill">Idle</span>
      </div>

      <div style="margin-top:12px;" class="row">
        <div class="meter"><div id="meterFill"></div></div>
        <span class="muted" id="meterText">Mic level</span>
      </div>

      <div class="divider"></div>

      <p class="big">
        <span id="speakerLabel">Speaker:</span> <b id="speakerNum">-</b> / <b id="speakerTotal">-</b>
        <span id="speakerState" class="pill">Waiting</span>
      </p>

      <p class="big">
        <span id="takeLabel">Take:</span> <b id="takeNum">0</b> / <b id="takeTotal">10</b>
        <span id="takeState" class="pill">Not recording</span>
      </p>

      <p class="muted" id="takesSummary">Recorded: 0 / 0</p>

      <div id="takesList" class="muted"></div>

      <h4 id="trainingLogTitle" style="margin-top: 18px; margin-bottom: 10px;">Training log</h4>
      <pre id="trainLog">(no training started)</pre>
    </div>
  </div>

<script>
  const $ = (id) => document.getElementById(id);

  const I18N = {
    en: {
      title: "microWakeWord Recorder",
      page_title: "üéôÔ∏è microWakeWord Personal Recorder",
      page_subtitle: "Enter a wake word, test TTS pronunciation, then record takes. Recording starts when you speak and stops after silence.",
      phrase_placeholder: "e.g. \"tater totterson\"",
      lang_title: "Language",
      lang_auto: "Auto",
      lang_en: "English",
      lang_ru: "Russian",
      start_session_btn: "Start session",
      tts_btn: "üîä Test TTS",
      session_none: "No session",
      label_speakers: "Speakers",
      label_takes_per_speaker: "Takes / speaker",
      speaker_pill_empty: "Speaker: -",
      advanced_summary: "Advanced (if it‚Äôs too sensitive / not sensitive enough)",
      label_start_sensitivity: "Start sensitivity",
      label_silence_stop: "Silence stop (ms)",
      label_min_take_length: "Min take length (ms)",
      unit_ms: "ms",
      begin_recording_btn: "üé¨ Begin recording",
      reset_recordings_btn: "üßπ Reset recordings",
      start_training_btn: "üß† Start training",
      status_idle: "Idle",
      meter_level: "Mic level",
      speaker_label: "Speaker:",
      take_label: "Take:",
      speaker_state_waiting: "Waiting",
      take_state_not_recording: "Not recording",
      take_state_ready: "Ready",
      takes_summary: "Recorded: {recorded}/{total}",
      training_log: "Training log",
      training_none: "(no training started)",
      training_preparing: "(preparing‚Ä¶)\n",
      training_waiting: "Waiting for training output‚Ä¶\n",
      error_mic_not_available: "Microphone not available here. Use https:// (or http://localhost) to record.",
      mic_stopped: "Mic stopped",
      meter_level_rms: "Mic level (rms={rms})",
      speaker_pill: "Speaker {current}/{total}",
      speaker_state_current: "Speaker {current}/{total}",
      speaker_state_complete: "Speaker {speaker} complete ‚úÖ",
      speaker_state_all_done: "All speakers done ‚úÖ",
      take_state_done: "Done",
      take_state_paused: "Paused",
      take_state_listening: "Listening‚Ä¶",
      take_state_recording: "Recording‚Ä¶",
      take_state_processing: "Processing‚Ä¶",
      take_state_error: "Error",
      status_uploading: "Uploading speaker {speaker} take {take}‚Ä¶",
      status_saved: "Saved speaker {speaker} take {take}/{total}",
      status_all_takes_recorded: "All takes recorded ‚úÖ",
      status_ready_for_speaker: "Ready for speaker {speaker}. Click Begin recording.",
      status_listening_say: "Listening‚Ä¶ say the wake word now",
      status_ready: "Ready",
      status_loaded_existing: "Loaded existing recordings",
      status_starting_session: "Starting‚Ä¶",
      status_session_failed: "Session failed",
      status_recordings_reset: "Recordings reset",
      status_upload_failed: "Upload failed",
      status_auto_training_start: "Auto-starting training‚Ä¶",
      status_training_preparing: "Preparing training environment‚Ä¶",
      status_training_running: "Training running‚Ä¶",
      status_training_finished: "Training finished ‚úÖ",
      status_training_ended: "Training ended (exit={code})",
      status_auto_train_failed: "Auto-train failed",
      status_train_failed: "Train failed",
      takes_list_existing: "Existing recordings: {recorded}/{total}",
      takes_list_saved: "Saved {take}/{takeTotal} takes for speaker {speaker}/{speakerTotal}",
      session_ok: "Session: {safe_word}",
      session_starting: "Starting‚Ä¶",
      session_failed: "Session failed",
      alert_phrase_required: "Enter a wake word phrase first.",
      alert_upload_failed: "Upload failed: {message}",
      alert_start_session_failed: "Start session failed: {message}",
      alert_mic_permission_failed: "Mic permission failed: {message}",
      alert_reset_failed: "Reset failed: {message}",
      alert_train_failed: "Train failed: {message}",
      alert_auto_train_failed: "Auto-start training failed: {message}",
      alert_start_session_first: "Start a session first.",
      confirm_no_personal_samples: "No personal voice samples recorded (0/{total}).\n\nTrain anyway WITHOUT personal voices?"
    },
    ru: {
      title: "microWakeWord –†–µ–∫–æ—Ä–¥–µ—Ä",
      page_title: "üéôÔ∏è –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∫–æ—Ä–¥–µ—Ä microWakeWord",
      page_subtitle: "–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤—É—é —Ñ—Ä–∞–∑—É, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–æ–∏–∑–Ω–æ—à–µ–Ω–∏–µ TTS, –∑–∞—Ç–µ–º –∑–∞–ø–∏—Å—ã–≤–∞–π—Ç–µ —Ç–µ–π–∫–∏. –ó–∞–ø–∏—Å—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ –≤—ã –≥–æ–≤–æ—Ä–∏—Ç–µ, –∏ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ —Ç–∏—à–∏–Ω—ã.",
      phrase_placeholder: "–Ω–∞–ø—Ä–∏–º–µ—Ä, \"–ø—Ä–∏–≤–µ—Ç –¥–æ–º\"",
      lang_title: "–Ø–∑—ã–∫",
      lang_auto: "–ê–≤—Ç–æ",
      lang_en: "–ê–Ω–≥–ª–∏–π—Å–∫–∏–π",
      lang_ru: "–†—É—Å—Å–∫–∏–π",
      start_session_btn: "–ù–∞—á–∞—Ç—å —Å–µ—Å—Å–∏—é",
      tts_btn: "üîä –ü—Ä–æ–≤–µ—Ä–∏—Ç—å TTS",
      session_none: "–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞—á–∞—Ç–∞",
      label_speakers: "–°–ø–∏–∫–µ—Ä—ã",
      label_takes_per_speaker: "–ó–∞–ø–∏—Å–µ–π / —Å–ø–∏–∫–µ—Ä",
      speaker_pill_empty: "–°–ø–∏–∫–µ—Ä: -",
      advanced_summary: "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ (—Å–ª–∏—à–∫–æ–º —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ / –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ)",
      label_start_sensitivity: "–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å—Ç–∞—Ä—Ç–∞",
      label_silence_stop: "–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ —Ç–∏—à–∏–Ω–µ (–º—Å)",
      label_min_take_length: "–ú–∏–Ω. –¥–ª–∏–Ω–∞ –∑–∞–ø–∏—Å–∏ (–º—Å)",
      unit_ms: "–º—Å",
      begin_recording_btn: "üé¨ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å",
      reset_recordings_btn: "üßπ –°–±—Ä–æ—Å–∏—Ç—å –∑–∞–ø–∏—Å–∏",
      start_training_btn: "üß† –ù–∞—á–∞—Ç—å –æ–±—É—á–µ–Ω–∏–µ",
      status_idle: "–û–∂–∏–¥–∞–Ω–∏–µ",
      meter_level: "–£—Ä–æ–≤–µ–Ω—å –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞",
      speaker_label: "–°–ø–∏–∫–µ—Ä:",
      take_label: "–¢–µ–π–∫:",
      speaker_state_waiting: "–û–∂–∏–¥–∞–Ω–∏–µ",
      take_state_not_recording: "–ù–µ –∑–∞–ø–∏—Å—ã–≤–∞–µ–º",
      take_state_ready: "–ì–æ—Ç–æ–≤–æ",
      takes_summary: "–ó–∞–ø–∏—Å–∞–Ω–æ: {recorded}/{total}",
      training_log: "–õ–æ–≥ –æ–±—É—á–µ–Ω–∏—è",
      training_none: "(–æ–±—É—á–µ–Ω–∏–µ –Ω–µ –Ω–∞—á–∏–Ω–∞–ª–æ—Å—å)",
      training_preparing: "(–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞‚Ä¶)\n",
      training_waiting: "–û–∂–∏–¥–∞–Ω–∏–µ –≤—ã–≤–æ–¥–∞ –æ–±—É—á–µ–Ω–∏—è‚Ä¶\n",
      error_mic_not_available: "–ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ https:// (–∏–ª–∏ http://localhost) –¥–ª—è –∑–∞–ø–∏—Å–∏.",
      mic_stopped: "–ú–∏–∫—Ä–æ—Ñ–æ–Ω –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
      meter_level_rms: "–£—Ä–æ–≤–µ–Ω—å –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ (rms={rms})",
      speaker_pill: "–°–ø–∏–∫–µ—Ä {current}/{total}",
      speaker_state_current: "–°–ø–∏–∫–µ—Ä {current}/{total}",
      speaker_state_complete: "–°–ø–∏–∫–µ—Ä {speaker} –∑–∞–≤–µ—Ä—à–µ–Ω ‚úÖ",
      speaker_state_all_done: "–í—Å–µ —Å–ø–∏–∫–µ—Ä—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã ‚úÖ",
      take_state_done: "–ì–æ—Ç–æ–≤–æ",
      take_state_paused: "–ü–∞—É–∑–∞",
      take_state_listening: "–°–ª—É—à–∞—é‚Ä¶",
      take_state_recording: "–ó–∞–ø–∏—Å—å‚Ä¶",
      take_state_processing: "–û–±—Ä–∞–±–æ—Ç–∫–∞‚Ä¶",
      take_state_error: "–û—à–∏–±–∫–∞",
      status_uploading: "–ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø–∏–∫–µ—Ä {speaker} —Ç–µ–π–∫ {take}‚Ä¶",
      status_saved: "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ —Å–ø–∏–∫–µ—Ä {speaker} —Ç–µ–π–∫ {take}/{total}",
      status_all_takes_recorded: "–í—Å–µ –∑–∞–ø–∏—Å–∏ —Å–¥–µ–ª–∞–Ω—ã ‚úÖ",
      status_ready_for_speaker: "–ì–æ—Ç–æ–≤–æ –¥–ª—è —Å–ø–∏–∫–µ—Ä–∞ {speaker}. –ù–∞–∂–º–∏—Ç–µ \"–ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å\".",
      status_listening_say: "–°–ª—É—à–∞—é‚Ä¶ —Å–∫–∞–∂–∏—Ç–µ –∫–ª—é—á–µ–≤—É—é —Ñ—Ä–∞–∑—É",
      status_ready: "–ì–æ—Ç–æ–≤–æ",
      status_loaded_existing: "–ó–∞–≥—Ä—É–∂–µ–Ω—ã —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∑–∞–ø–∏—Å–∏",
      status_starting_session: "–ó–∞–ø—É—Å–∫‚Ä¶",
      status_session_failed: "–°–µ—Å—Å–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å",
      status_recordings_reset: "–ó–∞–ø–∏—Å–∏ —Å–±—Ä–æ—à–µ–Ω—ã",
      status_upload_failed: "–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å",
      status_auto_training_start: "–ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –æ–±—É—á–µ–Ω–∏—è‚Ä¶",
      status_training_preparing: "–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –æ–±—É—á–µ–Ω–∏—è‚Ä¶",
      status_training_running: "–û–±—É—á–µ–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ‚Ä¶",
      status_training_finished: "–û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ ‚úÖ",
      status_training_ended: "–û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ (–∫–æ–¥={code})",
      status_auto_train_failed: "–ê–≤—Ç–æ–æ–±—É—á–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å",
      status_train_failed: "–û–±—É—á–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å",
      takes_list_existing: "–ò–º–µ—é—Ç—Å—è –∑–∞–ø–∏—Å–∏: {recorded}/{total}",
      takes_list_saved: "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {take}/{takeTotal} –¥–ª—è —Å–ø–∏–∫–µ—Ä–∞ {speaker}/{speakerTotal}",
      session_ok: "–°–µ—Å—Å–∏—è: {safe_word}",
      session_starting: "–ó–∞–ø—É—Å–∫‚Ä¶",
      session_failed: "–°–µ—Å—Å–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å",
      alert_phrase_required: "–°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤—É—é —Ñ—Ä–∞–∑—É.",
      alert_upload_failed: "–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å: {message}",
      alert_start_session_failed: "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—á–∞—Ç—å —Å–µ—Å—Å–∏—é: {message}",
      alert_mic_permission_failed: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É: {message}",
      alert_reset_failed: "–°–±—Ä–æ—Å –Ω–µ —É–¥–∞–ª—Å—è: {message}",
      alert_train_failed: "–û–±—É—á–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å: {message}",
      alert_auto_train_failed: "–ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –æ–±—É—á–µ–Ω–∏—è –Ω–µ —É–¥–∞–ª—Å—è: {message}",
      alert_start_session_first: "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—á–Ω–∏—Ç–µ —Å–µ—Å—Å–∏—é.",
      confirm_no_personal_samples: "–õ–∏—á–Ω—ã—Ö –≥–æ–ª–æ—Å–æ–≤—ã—Ö –ø—Ä–∏–º–µ—Ä–æ–≤ –Ω–µ—Ç (0/{total}).\n\n–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –æ–±—É—á–µ–Ω–∏–µ –ë–ï–ó –ª–∏—á–Ω—ã—Ö –≥–æ–ª–æ—Å–æ–≤?"
    }
  };

  function detectUiLang() {
    const langs = (navigator.languages && navigator.languages.length)
      ? navigator.languages
      : [navigator.language || "en"];
    const primary = String(langs[0] || "en").toLowerCase();
    if (primary.startsWith("ru")) return "ru";
    return "en";
  }

  let currentUiLang = detectUiLang();

  function t(key, vars) {
    const dict = I18N[currentUiLang] || I18N.en;
    let str = dict[key] || I18N.en[key] || key;
    if (vars) {
      str = str.replace(/\{(\w+)\}/g, (m, k) => (
        Object.prototype.hasOwnProperty.call(vars, k) ? String(vars[k]) : m
      ));
    }
    return str;
  }

  function applyTranslations() {
    document.documentElement.lang = currentUiLang;
    document.title = t("title");
    $("pageTitle").textContent = t("page_title");
    $("pageSubtitle").textContent = t("page_subtitle");
    $("phrase").placeholder = t("phrase_placeholder");
    $("langSelect").title = t("lang_title");
    $("langAutoOpt").textContent = t("lang_auto");
    $("langEnOpt").textContent = t("lang_en");
    $("langRuOpt").textContent = t("lang_ru");
    $("startSessionBtn").textContent = t("start_session_btn");
    $("ttsBtn").textContent = t("tts_btn");
    $("sessionPill").textContent = t("session_none");
    $("labelSpeakers").textContent = t("label_speakers");
    $("labelTakesPerSpeaker").textContent = t("label_takes_per_speaker");
    $("speakerPill").textContent = t("speaker_pill_empty");
    $("advancedSummary").textContent = t("advanced_summary");
    $("labelStartSensitivity").textContent = t("label_start_sensitivity");
    $("labelSilenceStop").textContent = t("label_silence_stop");
    $("labelMinTakeLength").textContent = t("label_min_take_length");
    $("beginBtn").textContent = t("begin_recording_btn");
    $("resetBtn").textContent = t("reset_recordings_btn");
    $("trainBtn").textContent = t("start_training_btn");
    $("status").textContent = t("status_idle");
    $("meterText").textContent = t("meter_level");
    $("speakerLabel").textContent = t("speaker_label");
    $("takeLabel").textContent = t("take_label");
    $("speakerState").textContent = t("speaker_state_waiting");
    $("takeState").textContent = t("take_state_not_recording");
    $("takesSummary").textContent = t("takes_summary", { recorded: 0, total: 0 });
    $("trainingLogTitle").textContent = t("training_log");
    $("trainLog").textContent = t("training_none");
  }

  applyTranslations();

  function setPill(el, text, cls) {
    el.className = "pill " + (cls || "");
    el.textContent = text;
  }

  async function api(path, opts) {
    opts = opts || {};
    // Always try to avoid cache for polling endpoints
    if (!opts.cache) opts.cache = "no-store";

    const res = await fetch(path, opts);
    const ct = res.headers.get("content-type") || "";
    const data = ct.includes("application/json") ? await res.json() : await res.text();
    if (!res.ok) {
      const err = (typeof data === "string") ? { error: data } : (data || {});
      const msg = err.error || err.message || JSON.stringify(err);
      const e = new Error(msg);
      e.details = err;
      throw e;
    }
    return data;
  }

  // -------------------- log auto-scroll (sticky to bottom) --------------------
  function isNearBottom(el, px = 40) {
    return (el.scrollHeight - el.scrollTop - el.clientHeight) <= px;
  }

  function setLogTextAutoScroll(el, text) {
    const stick = isNearBottom(el);
    el.textContent = text || "";
    if (stick) el.scrollTop = el.scrollHeight;
  }
  // --------------------------------------------------------------------------

  function detectLang(phrase) {
    return /[–ê-–Ø–∞-—è–Å—ë]/.test(phrase || "") ? "ru" : "en";
  }
  function resolveLang(phrase) {
    const sel = ($("langSelect").value || "auto").toLowerCase();
    return sel === "auto" ? detectLang(phrase) : sel;
  }

  let session = null;
  let isRunning = false;

  let stream = null;
  let audioCtx = null;
  let analyser = null;
  let source = null;

  let capturing = false;
  let startedAt = 0;
  let silenceStart = null;
  let floatChunks = [];
  let frameSize = 2048;

  let currentSpeaker = 1;
  let speakersTotal = 1;

  let currentTake = 0;
  let takesPerSpeaker = 10;
  let takesReceived = 0;

  // --- training poll (append mode; scrollback works) ---
  let trainingPollRunning = false;
  let trainingPollAbort = false;

  let logBuffer = "";          // full text we‚Äôve shown in the browser
  let lastChunk = "";          // last chunk we received (for de-dupe)
  let seenAnyOutput = false;

  function appendLogAutoScroll(el, chunk) {
    if (!chunk) return;
    const stick = isNearBottom(el);
    el.textContent += chunk;
    if (stick) el.scrollTop = el.scrollHeight;
  }

  function startThreshold() { return parseFloat($("startThresh").value); }
  function silenceStopMs() { return parseInt($("silenceMs").value, 10); }
  function minTakeMs() { return parseInt($("minTakeMs").value, 10); }

  function updateAdvancedLabels() {
    $("startThreshVal").textContent = startThreshold().toFixed(3);
    const msUnit = t("unit_ms");
    $("silenceMsVal").textContent = silenceStopMs() + msUnit;
    $("minTakeMsVal").textContent = minTakeMs() + msUnit;
  }
  ["startThresh","silenceMs","minTakeMs"].forEach(id => $(id).addEventListener("input", updateAdvancedLabels));
  updateAdvancedLabels();

  function refreshUI() {
    $("speakerNum").textContent = String(currentSpeaker);
    $("speakerTotal").textContent = String(speakersTotal);
    $("takeNum").textContent = String(currentTake);
    $("takeTotal").textContent = String(takesPerSpeaker);
    setPill($("speakerPill"), t("speaker_pill", { current: currentSpeaker, total: speakersTotal }));
  }

  function updateTakesSummary() {
    const el = $("takesSummary");
    if (!el) return;
    const total = speakersTotal * takesPerSpeaker;
    el.textContent = t("takes_summary", { recorded: takesReceived, total });
  }

  function parseTakeFilename(name) {
    const m = /^speaker(\d+)_take(\d+)\.wav$/i.exec(name || "");
    if (!m) return null;
    return { speaker: parseInt(m[1], 10), take: parseInt(m[2], 10) };
  }

  function deriveProgressFromTakes(takes, speakersTotal, takesPerSpeaker) {
    const present = new Set();
    for (const name of (takes || [])) {
      const parsed = parseTakeFilename(name);
      if (!parsed) continue;
      if (parsed.speaker < 1 || parsed.speaker > speakersTotal) continue;
      if (parsed.take < 1 || parsed.take > takesPerSpeaker) continue;
      present.add(`${parsed.speaker}:${parsed.take}`);
    }

    const recorded = present.size;

    for (let s = 1; s <= speakersTotal; s++) {
      for (let t = 1; t <= takesPerSpeaker; t++) {
        if (!present.has(`${s}:${t}`)) {
          return { currentSpeaker: s, currentTake: t - 1, recorded, done: false };
        }
      }
    }

    return {
      currentSpeaker: speakersTotal,
      currentTake: takesPerSpeaker,
      recorded,
      done: true
    };
  }

  function applySessionSnapshot(sess) {
    if (!sess) return null;
    if (sess.speakers_total !== undefined) {
      speakersTotal = parseInt(sess.speakers_total || "1", 10);
    }
    if (sess.takes_per_speaker !== undefined) {
      takesPerSpeaker = parseInt(sess.takes_per_speaker || "10", 10);
    }

    const takes = Array.isArray(sess.takes) ? sess.takes : [];
    const progress = deriveProgressFromTakes(takes, speakersTotal, takesPerSpeaker);
    const reported = parseInt(sess.takes_received || "0", 10);

    currentSpeaker = progress.currentSpeaker;
    currentTake = progress.currentTake;
    takesReceived = Math.max(progress.recorded, isNaN(reported) ? 0 : reported);

    refreshUI();
    updateTakesSummary();

    if (takesReceived > 0) {
      $("takesList").textContent = t("takes_list_existing", {
        recorded: takesReceived,
        total: speakersTotal * takesPerSpeaker
      });
    } else {
      $("takesList").textContent = "";
    }

    return progress;
  }

  // -------------------- mic lifecycle --------------------
  async function ensureMic() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error(t("error_mic_not_available"));
    }
    if (stream) return;
    stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    source = audioCtx.createMediaStreamSource(stream);
    source.connect(analyser);
    requestAnimationFrame(meterLoop);
  }

  async function stopMicNow() {
    isRunning = false;
    capturing = false;

    const proc = window.__mw_proc;
    if (proc) {
      try { proc.disconnect(); } catch {}
      try { source && source.disconnect(proc); } catch {}
      window.__mw_proc = null;
    }

    if (stream) {
      try { stream.getTracks().forEach(t => t.stop()); } catch {}
      stream = null;
    }

    if (audioCtx) {
      try { await audioCtx.close(); } catch {}
      audioCtx = null;
    }

    analyser = null;
    source = null;

    $("meterFill").style.width = "0%";
    $("meterText").textContent = t("mic_stopped");
  }

  function meterLoop() {
    if (!analyser) {
      requestAnimationFrame(meterLoop);
      return;
    }

    const data = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(data);

    let sumSq = 0;
    for (let i=0;i<data.length;i++){
      const v = (data[i] - 128) / 128;
      sumSq += v*v;
    }
    const rms = Math.sqrt(sumSq / data.length);
    const pct = Math.min(100, Math.max(0, rms * 600));
    $("meterFill").style.width = pct + "%";
    $("meterText").textContent = t("meter_level_rms", { rms: rms.toFixed(3) });

    if (isRunning) recorderTick(rms);

    requestAnimationFrame(meterLoop);
  }

  // -------------------- recording state machine --------------------
  function recorderTick(rms) {
    const now = performance.now();

    if (!capturing) {
      if (rms >= startThreshold()) startCapture();
      return;
    }

    if (rms < startThreshold() * 0.65) {
      if (silenceStart === null) silenceStart = now;
      const silentFor = now - silenceStart;
      if (silentFor >= silenceStopMs()) {
        const dur = now - startedAt;
        if (dur >= minTakeMs()) stopCaptureAndUpload();
        else silenceStart = now;
      }
    } else {
      silenceStart = null;
    }
  }

  async function startCapture() {
    capturing = true;
    startedAt = performance.now();
    silenceStart = null;
    floatChunks = [];

    setPill($("takeState"), t("take_state_recording"), "warn");

    const proc = audioCtx.createScriptProcessor(frameSize, 1, 1);
    source.connect(proc);
    proc.connect(audioCtx.destination);

    proc.onaudioprocess = (ev) => {
      if (!capturing) return;
      const chan = ev.inputBuffer.getChannelData(0);
      floatChunks.push(new Float32Array(chan));
    };

    window.__mw_proc = proc;
  }

  async function stopCaptureAndUpload() {
    capturing = false;
    setPill($("takeState"), t("take_state_processing"));

    const proc = window.__mw_proc;
    if (proc) {
      try { proc.disconnect(); } catch {}
      try { source.disconnect(proc); } catch {}
      window.__mw_proc = null;
    }

    currentTake += 1;
    refreshUI();

    let totalLen = 0;
    for (const c of floatChunks) totalLen += c.length;
    const merged = new Float32Array(totalLen);
    let off = 0;
    for (const c of floatChunks) { merged.set(c, off); off += c.length; }

    const wavBlob = await floatToWav16kMono(merged, audioCtx.sampleRate);

    try {
      setPill($("status"), t("status_uploading", {
        speaker: currentSpeaker,
        take: currentTake
      }), "warn");

      const fd = new FormData();
      fd.append("speaker_index", String(currentSpeaker));
      fd.append("take_index", String(currentTake));
      fd.append("file", wavBlob, `take_${String(currentTake).padStart(2,"0")}.wav`);

      const uploadRes = await api("/api/upload_take", { method:"POST", body: fd });
      if (uploadRes && typeof uploadRes.takes_received === "number") {
        takesReceived = uploadRes.takes_received;
      } else {
        takesReceived += 1;
      }
      updateTakesSummary();

      $("takesList").textContent = t("takes_list_saved", {
        take: currentTake,
        takeTotal: takesPerSpeaker,
        speaker: currentSpeaker,
        speakerTotal: speakersTotal
      });
      setPill($("status"), t("status_saved", {
        speaker: currentSpeaker,
        take: currentTake,
        total: takesPerSpeaker
      }), "ok");

      if (currentTake >= takesPerSpeaker) {
        if (currentSpeaker >= speakersTotal) {
          setPill($("takeState"), t("take_state_done"), "ok");
          setPill($("speakerState"), t("speaker_state_all_done"), "ok");
          setPill($("status"), t("status_all_takes_recorded"), "ok");

          await stopMicNow();
          await autoStartTraining();
          return;
        }

        currentSpeaker += 1;
        currentTake = 0;
        refreshUI();

        setPill($("speakerState"), t("speaker_state_complete", {
          speaker: currentSpeaker - 1
        }), "ok");
        setPill($("takeState"), t("take_state_paused"), "warn");
        setPill($("status"), t("status_ready_for_speaker", {
          speaker: currentSpeaker
        }), "warn");

        isRunning = false;
        $("beginBtn").disabled = false;

        await stopMicNow();
        return;
      }

      setPill($("speakerState"), t("speaker_state_current", {
        current: currentSpeaker,
        total: speakersTotal
      }));
      setPill($("takeState"), t("take_state_listening"), "ok");

    } catch (e) {
      console.error(e);
      setPill($("status"), t("status_upload_failed"), "err");
      setPill($("takeState"), t("take_state_error"), "err");
      isRunning = false;
      $("beginBtn").disabled = false;
      alert(t("alert_upload_failed", { message: e.message }));
    }
  }

  // -------------------- WAV encoding helpers --------------------
  async function floatToWav16kMono(float32, srcRate) {
    const buf = audioCtx.createBuffer(1, float32.length, srcRate);
    buf.copyToChannel(float32, 0);

    const targetRate = 16000;
    const targetLen = Math.max(1, Math.round(float32.length * targetRate / srcRate));
    const offline = new OfflineAudioContext(1, targetLen, targetRate);

    const src = offline.createBufferSource();
    src.buffer = buf;
    src.connect(offline.destination);
    src.start(0);

    const rendered = await offline.startRendering();
    const data = rendered.getChannelData(0);

    const wav = encodeWavPCM16(data, targetRate);
    return new Blob([wav], { type: "audio/wav" });
  }

  function encodeWavPCM16(float32, sampleRate) {
    const numSamples = float32.length;
    const buffer = new ArrayBuffer(44 + numSamples * 2);
    const view = new DataView(buffer);

    function writeString(offset, str) {
      for (let i=0;i<str.length;i++) view.setUint8(offset+i, str.charCodeAt(i));
    }

    writeString(0, "RIFF");
    view.setUint32(4, 36 + numSamples * 2, true);
    writeString(8, "WAVE");

    writeString(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);

    writeString(36, "data");
    view.setUint32(40, numSamples * 2, true);

    let offset = 44;
    for (let i=0;i<numSamples;i++) {
      let s = Math.max(-1, Math.min(1, float32[i]));
      const v = s < 0 ? s * 0x8000 : s * 0x7fff;
      view.setInt16(offset, v, true);
      offset += 2;
    }
    return buffer;
  }

  // -------------------- training (manual + auto) --------------------
  async function startTrainingWithPrompt(auto=false) {
    const sess = await api("/api/session", { method: "GET" });
    const takesReceived = sess.takes_received || 0;
    const total = (sess.speakers_total || 1) * (sess.takes_per_speaker || 10);

    let allowNoPersonal = false;

    if (takesReceived === 0) {
      const ok = confirm(t("confirm_no_personal_samples", { total }));
      if (!ok) return;
      allowNoPersonal = true;
    }

    // lock UI immediately
    $("trainBtn").disabled = true;
    $("beginBtn").disabled = true;
    $("resetBtn").disabled = true;

    setPill($("status"), auto ? t("status_auto_training_start") : t("status_training_preparing"), "warn");

    // Reset log state for a fresh run
    trainingPollAbort = false;
    logBuffer = "";
    lastChunk = "";
    seenAnyOutput = false;

    const logEl = $("trainLog");
    logEl.textContent = t("training_preparing");

    try {
      // Kick off training first
      await api("/api/train", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ allow_no_personal: allowNoPersonal })
      });

      // Only start polling AFTER training was successfully kicked off
      if (!trainingPollRunning) {
        trainingPollRunning = true;
        pollTrainingTail();
      }

      setPill($("status"), t("status_training_running"), "warn");
    } catch (e) {
      $("trainBtn").disabled = false;
      $("resetBtn").disabled = false;
      $("beginBtn").disabled = false;
      trainingPollAbort = true;
      trainingPollRunning = false;
      throw e;
    }
  }

  async function autoStartTraining() {
    try {
      await startTrainingWithPrompt(true);
    } catch (e) {
      console.error(e);
      setPill($("status"), t("status_auto_train_failed"), "err");
      alert(t("alert_auto_train_failed", { message: e.message }));
    }
  }

  $("trainBtn").addEventListener("click", async () => {
    try {
      await startTrainingWithPrompt(false);
    } catch (e) {
      alert(t("alert_train_failed", { message: e.message }));
      setPill($("status"), t("status_train_failed"), "err");
    }
  });

  async function pollTrainingTail() {
    const logEl = $("trainLog");

    for (;;) {
      if (trainingPollAbort) {
        trainingPollRunning = false;
        break;
      }

      try {
        const st = await api(`/api/train_status?ts=${Date.now()}`, { method:"GET", cache:"no-store" });
        const tr = st.training || {};

        // NOTE: this assumes /api/train_status returns NEW output chunks (not full tail snapshots)
        const chunkRaw = tr.log_text || "";
        const chunk = chunkRaw; // keep exact newlines from server

        if (chunk) {
          // wipe placeholder once
          if (!seenAnyOutput) {
            logEl.textContent = "";
            logBuffer = "";
            lastChunk = "";
            seenAnyOutput = true;
          }

          // simple de-dupe: if server repeats the same chunk, skip it
          if (chunk !== lastChunk) {
            lastChunk = chunk;
            logBuffer += chunk;
            appendLogAutoScroll(logEl, chunk);
          }
        } else {
          // before first output, show waiting message but do NOT overwrite later scrollback
          if (!seenAnyOutput) {
            const noTrainingText = t("training_none");
            const preparingText = t("training_preparing").trimEnd();
            if (!logEl.textContent || logEl.textContent === noTrainingText || logEl.textContent.startsWith(preparingText)) {
              logEl.textContent = t("training_waiting");
            }
          }
        }

        const exitCodeIsSet = (tr.exit_code !== null && tr.exit_code !== undefined);

        if (!tr.running && exitCodeIsSet) {
          $("trainBtn").disabled = false;
          $("resetBtn").disabled = false;
          $("beginBtn").disabled = false;

          if (tr.exit_code === 0) setPill($("status"), t("status_training_finished"), "ok");
          else setPill($("status"), t("status_training_ended", { code: tr.exit_code }), "err");

          trainingPollRunning = false;
          break;
        }
      } catch (e) {
        // ignore transient polling errors
      }

      await new Promise(r => setTimeout(r, 1000));
    }
  }

  // -------------------- session + UI wiring --------------------
  $("ttsBtn").addEventListener("click", () => {
    const phrase = ($("phrase").value || "").trim();
    if (!phrase) return;
    const u = new SpeechSynthesisUtterance(phrase);
    const lang = resolveLang(phrase);
    u.lang = (lang === "ru") ? "ru-RU" : "en-US";
    speechSynthesis.cancel();
    speechSynthesis.speak(u);
  });

  $("startSessionBtn").addEventListener("click", async () => {
    const phrase = ($("phrase").value || "").trim();
    if (!phrase) { alert(t("alert_phrase_required")); return; }

    speakersTotal = parseInt($("speakersTotal").value || "1", 10);
    takesPerSpeaker = parseInt($("takesPerSpeaker").value || "10", 10);

    try {
      setPill($("sessionPill"), t("session_starting"), "warn");
      const data = await api("/api/start_session", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({
          phrase,
          lang: $("langSelect").value,
          speakers_total: speakersTotal,
          takes_per_speaker: takesPerSpeaker
        })
      });

      session = data;

      let progress = applySessionSnapshot(data);
      if (!progress) {
        currentSpeaker = 1;
        currentTake = 0;
        takesReceived = parseInt(data.takes_received || "0", 10);
        refreshUI();
        updateTakesSummary();
      }

      $("trainLog").textContent = t("training_none");

      // Stop any previous poll loop cleanly
      trainingPollAbort = true;
      trainingPollRunning = false;
      logBuffer = "";
      lastChunk = "";
      seenAnyOutput = false;

      await stopMicNow();

      setPill($("sessionPill"), t("session_ok", { safe_word: data.safe_word }), "ok");
      $("beginBtn").disabled = false;
      $("resetBtn").disabled = false;
      $("trainBtn").disabled = false;
      $("ttsBtn").disabled = false;

      setPill($("status"), t("status_ready"), "ok");
      setPill($("speakerState"), t("speaker_state_waiting"));
      setPill($("takeState"), t("take_state_not_recording"));

      if (progress && progress.done) {
        $("beginBtn").disabled = true;
        setPill($("status"), t("status_all_takes_recorded"), "ok");
        setPill($("speakerState"), t("speaker_state_all_done"), "ok");
        setPill($("takeState"), t("take_state_done"), "ok");
      } else if (takesReceived > 0) {
        setPill($("status"), t("status_loaded_existing"), "ok");
        setPill($("speakerState"), t("speaker_state_current", {
          current: currentSpeaker,
          total: speakersTotal
        }));
        setPill($("takeState"), t("take_state_ready"), "ok");
      }
    } catch (e) {
      console.error(e);
      setPill($("sessionPill"), t("session_failed"), "err");
      alert(t("alert_start_session_failed", { message: e.message }));
    } finally {
      // allow a new poll loop to start later
      trainingPollAbort = false;
    }
  });

  $("resetBtn").addEventListener("click", async () => {
    try {
      await api("/api/reset_recordings", {method:"POST"});
      currentSpeaker = 1;
      currentTake = 0;
      takesReceived = 0;
      $("takesList").textContent = "";
      refreshUI();
      updateTakesSummary();
      setPill($("status"), t("status_recordings_reset"), "ok");
    } catch (e) {
      alert(t("alert_reset_failed", { message: e.message }));
    }
  });

  $("beginBtn").addEventListener("click", async () => {
    if (!session) { alert(t("alert_start_session_first")); return; }
    try {
      await ensureMic();
    } catch (e) {
      alert(t("alert_mic_permission_failed", { message: e.message }));
      return;
    }

    $("takesList").textContent = "";
    refreshUI();

    isRunning = true;
    $("beginBtn").disabled = true;

    setPill($("speakerState"), t("speaker_state_current", {
      current: currentSpeaker,
      total: speakersTotal
    }));
    setPill($("status"), t("status_listening_say"), "ok");
    setPill($("takeState"), t("take_state_listening"), "ok");
  });
</script>
</body>
</html>
